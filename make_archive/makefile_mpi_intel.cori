# makefile producing MPI version of cql3d.

# YuP[2019-05-31] Made adjustments, based on makefile_gfortran64.CentOS7
# by Garrett Wright

# May/06:  makefile_mpi.xxx  is a system setup by Nikolai Ershov
#          for creation of mpi version of cql3d from the serial
#          version.   Therefore, only one version of cql3d needs
#          be maintained.
#          Comments (beginning with !MPI) have been inserted in the source.
#          These are processed using python code from the ./mpi subdirectory
#          to produce an MPI cql3d version.
#          The procedure is described in CompX report 
#          CQL3D_Parallelization_CompX-2006-1.pdf, and has been evolved
#          by Yuri Petrov.
#          Please follow this procedure in future cql3d modifications.

#Make sure have intel environment:
#module list
#Else switch environment:
#For example: module swap PrgEnv-xxx PrgEnv-intel

#make sure have netcdf libraries and includes:
#module unload darshan; module load cray-netcdf; module load cray-hdf5

#YuP[April 2017] It is strongly advised to add into your .bashrc.ext script:
#   export FORT_BUFFERED=1
# or into your .cshrc.ext script:
#   setenv FORT_BUFFERED 1
# It was the default option for NERSC in 2016,
# but it was disabled by NERSC personnel in 2017
# because of problems with some newer compilers.
# As a result of this change, the MPI runs became slower by ~3x
# when there is I/O of data into one file from all cores.



SHELL     = /bin/sh
NAME      = xcql3d_mpi.intel
COMPILER=	ftn
BUILDER=	$(COMPILER)

###INCLUDES  = frcomm.h frname.h frname_decl.h name.h trans.h wpadvnc.h
# INCLUDE line
include include_dependency.mk



# SOURCE line
include source_dependency.mk
#---------- NEED TO ADD mpilib.f90 into source_dependency.mk --------------

F90OBJECTS = $(filter %.o,$(SOURCES:.f90=.o))
OBJECTS = $(filter %.o,$(SOURCES:.f=.o))

#LOCATION=	-L/usr/lib64  -L/usr/local/pgplot
#LOCATION=	     -L/global/homes/j/jaegeref/pgplot_xt3
LOCATION=	 -L$(NETCDF_DIR)/lib -L$(HDF5_DIR)/lib -L/global/homes/u/u650/pgplot.edison/5.2/cnl2.0_ifort/lib
LIBS = \
 $(LOCATION) -lpgplot -lnetcdff -lnetcdf

#Location of netcdf.inc:
INCLUDE= $(NETCDF_DIR)/include
# -g is full debug;   -gopt allows optimization
DEBUG     = -g
OPTIMIZE  = -fast
LISTING   = -Mlist/etc/shells
CSPECIAL  =
SPECIAL   = -byteswapio -Mbackslash
#LDSPECIAL = -Wl,-noinhibit-exec 
LDSPECIAL = 
#COMPILE   = $(COMPILER) -c $(CSPECIAL) $(INCLUDE) $(DEBUG) # or use $(OPTIMIZE)
COMPILE   =  $(COMPILER) -c $(CSPECIAL) $(INCLUDE) $(OPTIMIZE) # or use $(DEBUG)
LOAD      = $(BUILDER) -o $(NAME) $(LDSPECIAL) $(OPTIMIZE) # $(DEBUG)
PROTECT   = chmod 755
DELETE    = rm -f

# The following gives suffixes to be used in checking for suffix rules.
# Written without dependencies, it may be useful to turn of such checking?
.SUFFIXES:

$(NAME):           $(F90OBJECTS) $(OBJECTS)
	$(LOAD)    $(F90OBJECTS) $(OBJECTS) $(LOCATION) $(LIBS)
	$(PROTECT) $(NAME)

# Following use of pattern matching works; 
# it is based on statements in Sect. 10.7 of gmake Manual
# by Stallman and McGrath.
# However, the two rules following this seem clearer to me (BobH).
#%.o:               %.f        $(INCLUDES)
#	$(COMPILE) $< -o $@

#include deps   #Introduced by John Wright (JCW)
$(SOURCES):        $(INCLUDES)
#----
# Now that we have modules and scope,
#   we unfortunately do have dependencies.
# Do not fret, they're not so bad.
#DAGOBJS = param.o cqlcomm.o r8subs.o advnce.o pltmain.o \
#          pltdf.o eqrhopsi.o equilib.o \
#          impavnc0.o  frplteq.o tdeqdsk.o bsu.o bsl.o
# And this describes their dag...
include module_dependency.mk


#----
# From here we will assume that all deps to build
# remaining files have been met.
# (Other words, we assume remaining .f files 
#  require all DAGOBJS.
# That is overkill, but simple.
# As files migrate or evolve, we add small rules for each file.
# This will also document how the code is structured in practice.

#GBW, until all files have the same extension (90 I hope!)
# filter out objects with correct extension

# see Sect. 4.10.1, Static Pattern Rules.
$(filter %.o,$(F90OBJECTS)): %.o: %.f90 $(INCLUDES)
	mpi/doparallel.py $< $*_mpitmp.f90 mpi/mpins_par.f
	$(COMPILE) $*_mpitmp.f90 -o $@

$(filter %.o,$(OBJECTS)): %.o: %.f  $(INCLUDES)
	mpi/doparallel.py $< $*_mpitmp.f mpi/mpins_par.f
	$(COMPILE) $*_mpitmp.f -o $@

#Changes introduced by JCW so obtain saved copy of mpi modified sources
#	mpi/doparallel.py $< mpitmp.f mpi/mpins_par.f
#	$(COMPILE) mpitmp.f -o $@
#	mpi/doparallel.py $< $*_mpitmp.f mpi/mpins_par.f
#	$(COMPILE) $*_mpitmp.f -o $@

rebuild:
	$(COMPILE) $(SOURCES) $(F90SOURCES)
	$(LOAD) $(OBJECTS)  $(F90OBJECTS) $(LOCATION) $(LIBS)

clean:
	$(DELETE)  $(OBJECTS) $(F90OBJECTS) *.lst *_mpitmp.f
	$(DELETE) *.mod
